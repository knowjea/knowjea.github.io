---
layout: post
title: "[Spring] 4장. 예외"
author: "Know jea"
categories: 토비의스프링
tags: [Spring, Java, 토비의 스프링]
comments: true
---

1. **사라진 SQLException**
    - JdbcTemplate로 변경 후 **throws SQLException**이 사라졌다.

        ```java
        // 변경 전
        public void deleteAll() throws SQLException {
        	this.jdbcContext.executeSql("delete from users");	
        }

        // 변경 후
        public void deleteAll() {
        	this.jdbcTemplate.update("delete from users");	
        }
        ```

    1. **초난감 예외처리**
        - SQLException을 알아보기 전에 간단한 초난감 예외처리를 살펴보자.

            ```java
            // 예외를 catch하고 아무것도 하지 않는 코드. 
            // 절대 이렇게 짜서는 안된다.
            try{
            	...
            } catch(SQLException e){

            }

            // 출력은 해주나, 다른 로그에 묻혀버리기 십상이다.
            try{
            	...
            } catch(SQLException e){
            	System.out.println(e);
            }

            // 마찬가지로 묻혀버리기 십상이다. 양심에 찔린다..
            try{
            	...
            } catch(SQLException e){
            	e.printStacTrace();
            }
            ```

        - 무의미하고 무책임한 throws. 자신이 예외처리 하기 싫으니 계속 throws를 던지는 코드

            ```java
            public void method1() throws Exception {
            	method2();
            }

            public void method2() throws Exception {
            	method3();
            }
            ```

    2. **예외의 종류와 특징**
        - **java.lang.Error :** 시스템이 비정상적인 상황이 발생했을 경우에 사용되며, 주로 JVM에서 발생시킨다. 따라서 특별한 처리를 할 필요 없다.
        - **java.lang.Exception** : 코드를 실행 중에 예외상황이 발생했을 경우에 사용되며, 체크 예외와 언체크 예외로 구분된다.
            - 체크 예외 : RuntimeException은 상속받지 않는 예외. 이 예외는 catch 또는 thorws로 잡아야지 컴파일 에러가 나지 않음.
            - 언체크 예외 : RuntimeException을 상속받는 예외. 명시적으로 예외처리를 강제하지 않음.
    3. **예외처리 방법**
        - **예외복구 :** 예외가 발생해도, 문제를 해결하고 정상상태로 돌려놓는 방식.

            ```java
            // 재시도를 통해 예외 복구
            int retry = 3;
            while(retry-- > 0){
            	try{
            		...
            	} catch(...){
            		
            	}
            }
            // 예외 복구 실패시, 최종적으로는 예외를 던진다.
            throw new RetryFailedException();
            ```

        - **예외처리 회피 :** 예외를 자신이 처리하지 않고, throw. 예외를 회피하는 것은 의도가 분명해야 하며, 자신을 호출한 곳에서 예외처리 책임을 분명히 지게 해야 한다.
        - **예외 전환** :  ****예외를 다른 예외로 전환.
            - 의미를 분명한 예외로 전환

                ```java
                public void add(User user) throws DuplicateUserIdException, SQLException {
                		try{
                				...
                		} catch(SQLException e){
                			// 에러를 파악해서 좀 더 분명한 에러를 자신이 만들어서 던짐
                			if(e.getErrorCode == MysqlErrorNumber.EP_DUL_ENTRY)
                				throw DuplicateUserIdException(e); // 에러의 근본 원인도 알려주기 위해 이전 예외를 포함시킴.
                			else
                				throw e;
                		}
                }
                ```

            - 예외를 간단하게 처리하도록 하기 위해 감싸서 전환. 예를 들어 프레임워크에서 관리하는 예외로 포장함.
    4. **예외처리 전략**
        - **런타임(언체크) 예외의 보편화 :** 체크 예외는 예외처리를 강제하는 것 때문에 무책임한 코드가 남발됐다고 비난하는 개발자도 많으며, 요즘 오픈소스들은 체크 예외를 만들지 않는 경향이 있다.
        - 따라서 앞 내용인 **예외 전환**에서 만든 DuplicateUserIdException도 사실 복구 가능한 예외이긴 하지만, 대부분의 SQLException은 복구불가능하므로 체크 예외보다는 언체크 예외로 만드는 편이 좋다.

            ```java
            public class DuplicateUserIdException extends RuntimeException {
            		public DuplicateUserIdException(Throwable cause){
            		super(cause);
            	}
            }
            ```

        - 언체크 예외로 수정한 add 메소드는 다음과 같다.

            ```java
            public void add(User user) throws DuplicateUserIdException {
            		try{
            				...
            		} catch(SQLException e){
            			if(e.getErrorCode == MysqlErrorNumber.EP_DUL_ENTRY)
            				throw new DuplicateUserIdException(e);
            			else
            				throw new RuntimeException(e); // SQLException도 런타임으로 포장
            		}
            }
            ```

        - **애플리케이션 예외** : 시스템 또는 외부의 예외상황이 원인이 아닌 애플리케이션 로직에 의해 발생한 예외를 칭한다. 예외가 발생할 경우 코드에서는 보통 다음과 같이 처리한다.
            - 다른 종류의 값을 리턴 (ex: 0, -1). 이러면 개발자들끼리 미리 의사소통으로 정해야 하지만, 잘못될 수 있으며, if문이 많아짐
            - 체크예외를 만들어 던져주기. 상대적으로 안전함
    5. **SQLException은 어떻게 됐나?**
        - SQLException은 복구할 방법이 거의 없으니 기계적인 throws 을 방치않게 Spring에서는 언체크/런타임 예외로 전환하였다.
        - Spring은 모든 SQLException을 DataAccessException으로 **예외전환** 방식을 사용하여 포장해서 던져준다.
        - Spring은 대부분의 예외는 런타임 예외